// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: url.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createURL = `-- name: CreateURL :one
INSERT INTO urls (
    id, short_code, url, user_id
)
VALUES ($1, $2, $3, $4)
RETURNING id, short_code, url, user_id, created_at
`

type CreateURLParams struct {
	ID        uuid.UUID
	ShortCode string
	Url       string
	UserID    uuid.UUID
}

func (q *Queries) CreateURL(ctx context.Context, arg CreateURLParams) (Url, error) {
	row := q.db.QueryRowContext(ctx, createURL,
		arg.ID,
		arg.ShortCode,
		arg.Url,
		arg.UserID,
	)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.Url,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const getOriginalUrl = `-- name: GetOriginalUrl :one
SELECT urls.url AS link FROM urls
LEFT JOIN aliases
    ON aliases.url_code = urls.short_code
WHERE aliases.alias = $1
   OR urls.short_code = $2
`

type GetOriginalUrlParams struct {
	Alias     string
	ShortCode string
}

func (q *Queries) GetOriginalUrl(ctx context.Context, arg GetOriginalUrlParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getOriginalUrl, arg.Alias, arg.ShortCode)
	var link string
	err := row.Scan(&link)
	return link, err
}

const getShortCodeAndAlias = `-- name: GetShortCodeAndAlias :one
SELECT urls.short_code AS code, aliases.alias AS alias
FROM urls
         LEFT JOIN aliases ON aliases.url_code = urls.short_code
WHERE $1 IN (aliases.alias, urls.short_code)
LIMIT 1
`

type GetShortCodeAndAliasRow struct {
	Code  string
	Alias sql.NullString
}

func (q *Queries) GetShortCodeAndAlias(ctx context.Context, alias string) (GetShortCodeAndAliasRow, error) {
	row := q.db.QueryRowContext(ctx, getShortCodeAndAlias, alias)
	var i GetShortCodeAndAliasRow
	err := row.Scan(&i.Code, &i.Alias)
	return i, err
}

const getURL = `-- name: GetURL :one
SELECT id, short_code, url, user_id, created_at FROM urls
WHERE short_code = $1
`

func (q *Queries) GetURL(ctx context.Context, shortCode string) (Url, error) {
	row := q.db.QueryRowContext(ctx, getURL, shortCode)
	var i Url
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.Url,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const getURLsForUser = `-- name: GetURLsForUser :many
SELECT
    users.id AS user_id,
    users.username AS name,
    urls.short_code,
    urls.url,
    aliases.alias AS alias
FROM urls
         LEFT JOIN aliases
                   ON urls.short_code = aliases.url_code
         JOIN users
              ON users.id = urls.user_id
WHERE urls.user_id = $1
`

type GetURLsForUserRow struct {
	UserID    uuid.UUID
	Name      string
	ShortCode string
	Url       string
	Alias     sql.NullString
}

func (q *Queries) GetURLsForUser(ctx context.Context, userID uuid.UUID) ([]GetURLsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getURLsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetURLsForUserRow
	for rows.Next() {
		var i GetURLsForUserRow
		if err := rows.Scan(
			&i.UserID,
			&i.Name,
			&i.ShortCode,
			&i.Url,
			&i.Alias,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUrlOwnerByShortCode = `-- name: GetUrlOwnerByShortCode :one
SELECT user_id
FROM urls
WHERE short_code = $1
LIMIT 1
`

func (q *Queries) GetUrlOwnerByShortCode(ctx context.Context, shortCode string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getUrlOwnerByShortCode, shortCode)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}
